Scale = function (modelWidthInFeet)
{
    ///////////////////// Unit conversions

    this.unitsToFt = modelWidthInFeet || 16.0;
    this.unitsToIn = this.unitsToFt * 12;
    this.unitsToM = this.unitsToIn * 2.54 / 100.0;
    this.unitsToPt = this.unitsToIn * 72;
    this.ftToUnits = 1.0 / this.unitsToFt;
    this.inToUnits = 1.0 / this.unitsToIn;
    this.mToUnits = 1.0 / this.unitsToM;
    this.ptToUnits = 1.0 / this.unitsToPt;

    ///////////////////// Fabrication parameters

    // Maximum size of panels to CNC
    this.cncSize = new Point(18 * this.inToUnits, 24 * this.inToUnits); 

    // Minimum material thickness between cuts
    this.cncMaterialThickness = 0.25 * this.inToUnits;

    // Minimum width of load-bearing pieces on middle layer
    this.supportWidth = this.inToUnits * 0.75;

    // Density and width of LED strip
    this.ledSpacing = this.mToUnits / 60.0;

    // Distance to let LED light spread nicely before entering large dots
    this.ledSpreadDistance = this.ledSpacing * 1.5;

    // Size and spacing of small dots
    this.smallDotDiameter = this.inToUnits * 0.5;
    this.smallDotRadius = this.smallDotDiameter / 2;
    this.smallDotGap = this.smallDotDiameter;

    // Distance to keep LED strips from small dots, to avoid glare.
    this.topLayerThickness = 0.75 * this.inToUnits;
    this.ledStripThickness = 12e-3 * this.mToUnits;
    this.ledSmallDotDistance = this.smallDotDiameter *
        this.ledStripThickness / this.topLayerThickness;

    // Distance between small dots and added freeform supports
    this.smallDotSupportGap = this.ledSmallDotDistance * 3;

    this.bounds = new Rectangle(0, 0, 1, 0.5);

    this.clipToBounds = function ( item ) {
        var bounds = new Path.Rectangle(this.bounds);
        var group = new Group(bounds);
        group.clipped = true;
        group.addChild(item);
        return group;
    }

    this.drawGrid = function ( rectangleToCover, minorUnit, majorUnit ) { 
        var group = new Group();

        minorUnit = minorUnit || this.inToUnits;
        majorUnit = majorUnit || this.ftToUnits;

        var extended = new Rectangle(rectangleToCover);
        extended.left = Math.floor(extended.left / majorUnit) * majorUnit;
        extended.top = Math.floor(extended.top / majorUnit) * majorUnit;
        extended.right = Math.ceil(extended.right / majorUnit) * majorUnit;
        extended.bottom = Math.ceil(extended.bottom / majorUnit) * majorUnit;
        extended = extended.intersect(this.bounds);

        // Minor axis, verticals
        for (var p = new Point(extended.topLeft); p.x <= extended.right; p.x += minorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.bottomLeft - extended.topLeft),
                strokeColor: new Color(0, 0.2),
                strokeWidth: 0.2,
                strokeScaling: false
            }));
        }

        // Major axis, verticals
        for (var p = new Point(extended.topLeft); p.x <= extended.right; p.x += majorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.bottomLeft - extended.topLeft),
                strokeColor: new Color(0, 0.8),
                strokeWidth: 0.5,
                strokeScaling: false
            }));
        }

        // Minor axis, horizontals
        for (var p = new Point(extended.topLeft); p.y <= extended.bottom; p.y += minorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.topRight - extended.topLeft),
                strokeColor: new Color(0, 0.2),
                strokeWidth: 0.2,
                strokeScaling: false
            }));
        }

        // Major axis, horizontals
        for (var p = new Point(extended.topLeft); p.y <= extended.bottom; p.y += majorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.topRight - extended.topLeft),
                strokeColor: new Color(0, 0.8),
                strokeWidth: 0.5,
                strokeScaling: false
            }));
        }

        return group;
    }
}


Growth = function (json)
{
    this.json = json;

    this.draw = function () {
        var group = new Group();

        for (var i = 0; i < this.json.panels.length; i++) {
            var panel = this.json.panels[i];

            var path = new Path({
                strokeColor: '#242',
                strokeWidth: 1,
                strokeCap: 'round',
                strokeScaling: false
            });

            path.addSegments(panel.outline);
            path.closePath();
            group.addChild(path);
        }

        for (var i = 0; i < this.json.dots.length; i++) {
            var dot = this.json.dots[i];

            var path = new Path.Circle({
                fillColor: '#422',
                center: dot.center,
                radius: dot.radius,
                strokeScaling: false
            });

            group.addChild(path);
        }

        for (var i = 0; i < this.json.strands.length; i++) {
            var strand = this.json.strands[i];

            var path = new Path({
                strokeColor: new Color(0, 0.4),
                strokeWidth: 0.5,
                strokeCap: 'round',
                strokeScaling: false
            });

            path.addSegments(strand.points);
            group.addChild(path);
        }

        return group;
    }
}


DotCollider = function ()
{
    this.list = [];

    this.add = function (point, radius)
    {
        this.list.push({ point: new Point(point), radius: radius });
    }

    this.hitTest = function (point, radius)
    {
        for (var i = 0; i < this.list.length; i++) {
            var dot = this.list[i];
            var distSquared = point.getDistance(dot.point, true);
            var r = dot.radius + radius;
            if (distSquared < r*r) {
                return true;
            }
        }
        return false;
    }
}


Panel = function ( growth, scale, panelId )
{
    this.growth = growth;
    this.scale = scale;
    this.panelId = panelId;
    this.json = growth.json.panels[panelId];

    this.drawOutline = function ()
    {
        var path = new Path(this.json.outline);
        path.closePath(true);
        return path;
    }

    this.offsetOutline = function (radius)
    {
        // Hack! Paper.js doesn't have outset/inset. Assuming rectangular panels.
        return new Path.Rectangle(this.bounds.expand(-2*radius));
    }

    this.outlineSupports = function ()
    {
        // Support pieces for the panel's outline
        return this.drawOutline().subtract(this.offsetOutline( this.scale.supportWidth ));
    }

    this.insideSupports = function ()
    {
        // Calculate the area inside the panel's outer supports
        return this.offsetOutline( this.scale.supportWidth );
    }

    this.nudgeLargeDot = function (json)
    {
        // The simulation may give us dots that need to move slightly in order to
        // have enough clearance for support pieces. Do that in the JSON model before
        // we use it for anything else.

        // TODO: Assumes panels are rectangular and axis-aligned

        var r = json.radius;
        var c = json.center;
        var b = this.bounds;
        var mt = this.scale.cncMaterialThickness;

        var clearance = 0.001 + r + this.scale.supportWidth + this.scale.ledSpreadDistance;

        c.x = Math.max(c.x, b.left + clearance);
        c.x = Math.min(c.x, b.right - clearance);

        c.y = Math.max(c.y, b.top + clearance);
        c.y = Math.min(c.y, b.bottom - clearance);

        // Another reason to move large dots a tiny bit: edges too close to
        // our front panel boundaries won't be manufacturable. Move inward
        // a little in this case.
        // TODO: assumptions about CNC layout should go elsewhere

        if (c.x + r > b.center.x - mt) c.x = Math.max(c.x, b.center.x - r + mt);
        if (c.y + r > b.center.y - mt) c.y = Math.max(c.y, b.center.y - r + mt);
        if (c.x - r < b.center.x + mt) c.x = Math.min(c.x, b.center.x + r - mt);
        if (c.y - r < b.center.y + mt) c.y = Math.min(c.y, b.center.y + r - mt);
    }

    this.placeLargeDot = function (json)
    {
        this.frontHoles.push(new Path.Circle(json.center, json.radius));

        // Support for fully isolated LED strip around the dot, pointed inward
        var ledRadius = json.radius + this.scale.ledSpreadDistance;
        var outerRadius = ledRadius + this.scale.supportWidth;

        this.middleSupports.push(new Path.Circle(json.center, outerRadius));
        this.middleHoles.push(new Path.Circle(json.center, ledRadius));

        // Large keepout area
        this.largeCollider.add(json.center, outerRadius);
    }

    this.canPlaceSmallDot = function (point)
    {
        if (!this.bounds.contains(point)) {
            // Not on this panel, early out.
            return false;
        }

        if (!this.smallDotBounds.contains(point)) {
            // Too close to LEDs mounted on edge
            return false;
        }

        if (this.largeCollider.hitTest(point, this.scale.smallDotRadius + this.scale.ledSmallDotDistance)) {
            // Too close to LEDs mounted outside large dots
            return false;
        } 

        if (this.smallCollider.hitTest(point, this.scale.smallDotRadius + this.scale.smallDotGap)) {
            // Too close to an earlier small dot
            return false;
        }

        return true;
    }

    this.canPlaceSupportIsland = function (point)
    {
        if (!this.supportBounds.contains(point)) {
            // Too close to border supports
            return false;
        }

        if (this.largeCollider.hitTest(point, this.scale.smallDotSupportGap * 2)) {
            // Too close to large dot supports
            return false;
        } 

        if (this.smallCollider.hitTest(point, this.scale.smallDotSupportGap)) {
            // Too close to a small dot
            return false;
        }

        return true;        
    }

    this.placeSmallDot = function (point)
    {
        this.smallCollider.add(point, this.scale.smallDotRadius);
        this.frontHoles.push(new Path.Circle(point, this.scale.smallDotRadius));
    } 

    this.placeStrand = function (json)
    {   
        var path = new Path(json.points);
        if (path.bounds.intersects(this.bounds)) {

            var offset = 0;
            var length = path.length;
            var dotsToPlace = []

            var r = this.scale.smallDotRadius;
            var b = this.bounds;
            var mt = this.scale.cncMaterialThickness;

            while (offset < length) {
                var point = path.getPointAt(offset);

                if (this.canPlaceSmallDot(point)) {
                    // Place the dots later so we don't collide-test on the same strand
                    dotsToPlace.push(point);
                }

                offset += r * 2 + this.scale.smallDotGap;
            }

            for (var i = 0; i < dotsToPlace.length; i++) {
                this.placeSmallDot(dotsToPlace[i]);
            }
        }
        path.remove();
    }

    this.splitIntoGrid = function (layer, maxSize)
    {
        var partSize = new Point(
            layer.bounds.width / Math.ceil(layer.bounds.width / maxSize.x),
            layer.bounds.height / Math.ceil(layer.bounds.height / maxSize.y));

        var epsilon = new Point( this.scale.inToUnits * 0.01, this.scale.inToUnits * 0.01 ); 

        var parts = []
        var r = layer.bounds;

        for (var y = r.top; y < r.bottom; y += partSize.y) {
            for (var x = r.left; x < r.right; x += partSize.x) {
                var p = new Point(x, y);
                var cell = new Path.Rectangle( p + epsilon, p + partSize - epsilon );
                parts.push(layer.intersect(cell));
            }
        }

        return new Group(parts);
    }

    this.outline = this.drawOutline();
    this.bounds = this.outline.bounds;
    this.largeCollider = new DotCollider();
    this.smallCollider = new DotCollider();

    this.smallDotBounds = this.offsetOutline(
        this.scale.ledSmallDotDistance +
        this.scale.smallDotRadius +
        this.scale.supportWidth);

    this.supportBounds = this.offsetOutline(
        this.scale.smallDotSupportGap * 2 +
        this.scale.supportWidth);

    // Paths to aggregate during dot placement
    this.frontHoles = [];
    this.middleSupports = [];
    this.middleHoles = [];

    // Place large dots

    for (var i = 0; i < this.growth.json.dots.length; i++) {
        var dot = this.growth.json.dots[i];
        if (this.bounds.contains(dot.center)) {
            this.nudgeLargeDot(dot);
            this.placeLargeDot(dot);
        }
    }

    // Place small dots along strands

    for (var i = 0; i < this.growth.json.strands.length; i++) {
        this.placeStrand(this.growth.json.strands[i]);
    }

    // Search a grid for additional support islands

    this.supportIslands = new Group();
    for (var x = this.bounds.left; x < this.bounds.right; x += this.scale.smallDotRadius) {
        for (var y = this.bounds.top; y < this.bounds.bottom; y += this.scale.smallDotRadius) {
            var point = new Point(x, y);
            if (this.canPlaceSupportIsland(point)) {
                var r = new Point(this.scale.smallDotRadius * 1.1,
                                  this.scale.smallDotRadius * 1.1);
                var part = new Path.Rectangle(point - r, point + r);
                part.fillColor = '#ff2';
                this.supportIslands.addChild(part);
            }
        }
    }

    for (var i = 0; i < this.supportIslands.children.length; i++) {
        var island = this.supportIslands.children[i];
        //island.simplify(5e-6);
        console.log("Island " + i + ", area " + island.area);
    }

    // Construct layers from path lists

    this.frontLayer = this.outline.subtract(new CompoundPath(this.frontHoles));
    this.middleLayer = new CompoundPath(this.middleSupports)
        .subtract(new CompoundPath(this.middleHoles))
        .unite(this.outlineSupports());
    this.backLayer = this.outline.clone();

    // Candidate locations for LED strip placement: Start with the middle layer
    this.ledStripPaths = this.middleLayer.clone();
 
    // Remove the outline path; don't put LEDs on the outside of the panel.
    this.ledStripPaths.hitTest(this.outline.segments[0].point).item.remove();

    for (var i = 0; i < this.ledStripPaths.children.length; i++) {
        var path = this.ledStripPaths.children[i];
        var length = path.length;
        var maxLeds = Math.floor(length / this.scale.ledSpacing);
        console.log("LED strip path " + i + ", length " + length + ", " + maxLeds + " LEDs max");
    }

    // Split front layer into quadrants
    this.frontLayer = this.splitIntoGrid(this.frontLayer, this.scale.cncSize);

    this.draw = function ()
    {
        this.backLayer.fillColor   = '#21abff';                     // Bright rear layer
        this.middleLayer.fillColor = new Color(0, 0.6, 0, 0.8);     // Green support layer
        this.frontLayer.fillColor  = new Color(0, 0.7);             // Dark front layer
        this.ledStripPaths.selected = true;

        var group = new Group();
        group.addChild(this.backLayer);
        group.addChild(this.middleLayer);
        group.addChild(this.frontLayer);
        //group.addChild(this.ledStripPaths);
        //group.addChild(this.supportIslands);

        return group;
    }

    this.drawFront = function ()
    {
        this.frontLayer.fillColor = '#000';
        return this.frontLayer;
    }

    this.drawMiddle = function ()
    {
        this.middleLayer.fillColor = '#000';
        return this.middleLayer;
    }

    this.drawBack = function ()
    {
        this.backLayer.fillColor = '#000';
        return this.backLayer;
    }
}


MakeDiagramPage = function (item, scale)
{
    var world = new Group();
    world.addChild(item);
    world.addChild(scale.drawGrid(item.bounds));

    world.fitBounds(view.bounds.expand(-100));
    world.scale(1, -1);

    var layer = new Layer(world);
    layer.activate();
    return layer;
}


MakeActualSizePage = function (item, scale)
{
    var world = new Group();
    world.addChild(item);

    world.scale( scale.unitsToPt, -scale.unitsToPt );
    world.translate( view.center - world.center );

    var layer = new Layer(world);
    layer.activate();
    return layer;
}
