strokePath = function (path, radius)
{
    // Hack! Paper.js doesn't have outset/inset yet

    var result = null;

    for (var i = 0; i < path.segments.length - !path.closed; i++) {
        var p1 = path.segments[i].point;
        var p2 = path.segments[(i+1) % path.segments.length].point;

        var p = new Path();
        var d = p2 - p1;
        var tangent = d.rotate(90).normalize(radius);
        p.add( p1 + tangent );
        p.add( p2 + tangent );
        p.add( p2 - tangent );
        p.add( p1 - tangent );
        p.closePath();

        result = result ? result.unite(p) : p;

        result = result.unite(new Path.Circle(p1, radius * 0.999));
        result = result.unite(new Path.Circle(p2, radius * 0.999));
    }

    return result;
}


Scale = function (modelWidthInFeet)
{
    this.unitsToFt = modelWidthInFeet || 16.0;
    this.unitsToIn = this.unitsToFt * 12;
    this.unitsToM = this.unitsToIn * 2.54 / 100.0;
    this.ftToUnits = 1.0 / this.unitsToFt;
    this.inToUnits = 1.0 / this.unitsToIn;
    this.mToUnits = 1.0 / this.unitsToM;
    this.supportWidth = this.inToUnits * 0.75;
    this.ledSpacing = this.mToUnits / 60.0;
    this.ledSpreadDistance = this.ledSpacing * 1.5;
    this.smallDotRadius = this.inToUnits * 0.5 / 2;
    this.smallDotGap = this.smallDotRadius * 2;
    this.bounds = new Rectangle(0, 0, 1, 0.5);

    this.clipToBounds = function ( item ) {
        var bounds = new Path.Rectangle(this.bounds);
        var group = new Group(bounds);
        group.clipped = true;
        group.addChild(item);
        return group;
    }

    this.drawGrid = function ( rectangleToCover, minorUnit, majorUnit ) { 
        var group = new Group();

        minorUnit = minorUnit || this.inToUnits;
        majorUnit = majorUnit || this.ftToUnits;

        var extended = new Rectangle(rectangleToCover);
        extended.left = Math.floor(extended.left / majorUnit) * majorUnit;
        extended.top = Math.floor(extended.top / majorUnit) * majorUnit;
        extended.right = Math.ceil(extended.right / majorUnit) * majorUnit;
        extended.bottom = Math.ceil(extended.bottom / majorUnit) * majorUnit;
        extended = extended.intersect(this.bounds);

        // Minor axis, verticals
        for (var p = new Point(extended.topLeft); p.x <= extended.right; p.x += minorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.bottomLeft - extended.topLeft),
                strokeColor: new Color(0, 0.2),
                strokeWidth: 0.2,
                strokeScaling: false
            }));
        }

        // Major axis, verticals
        for (var p = new Point(extended.topLeft); p.x <= extended.right; p.x += majorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.bottomLeft - extended.topLeft),
                strokeColor: new Color(0, 0.8),
                strokeWidth: 0.5,
                strokeScaling: false
            }));
        }

        // Minor axis, horizontals
        for (var p = new Point(extended.topLeft); p.y <= extended.bottom; p.y += minorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.topRight - extended.topLeft),
                strokeColor: new Color(0, 0.2),
                strokeWidth: 0.2,
                strokeScaling: false
            }));
        }

        // Major axis, horizontals
        for (var p = new Point(extended.topLeft); p.y <= extended.bottom; p.y += majorUnit) {
            group.addChild(new Path.Line({
                from: p,
                to: p + (extended.topRight - extended.topLeft),
                strokeColor: new Color(0, 0.8),
                strokeWidth: 0.5,
                strokeScaling: false
            }));
        }

        return group;
    }
}


Growth = function (json)
{
    this.json = json;

    this.draw = function () {
        var group = new Group();

        for (var i = 0; i < this.json.panels.length; i++) {
            var panel = this.json.panels[i];

            var path = new Path({
                strokeColor: '#242',
                strokeWidth: 1,
                strokeCap: 'round',
                strokeScaling: false
            });

            path.addSegments(panel.outline);
            path.closePath();
            group.addChild(path);
        }

        for (var i = 0; i < this.json.dots.length; i++) {
            var dot = this.json.dots[i];

            var path = new Path.Circle({
                fillColor: '#422',
                center: dot.center,
                radius: dot.radius,
                strokeScaling: false
            });

            group.addChild(path);
        }

        for (var i = 0; i < this.json.strands.length; i++) {
            var strand = this.json.strands[i];

            var path = new Path({
                strokeColor: new Color(0, 0.4),
                strokeWidth: 0.5,
                strokeCap: 'round',
                strokeScaling: false
            });

            path.addSegments(strand.points);
            group.addChild(path);
        }

        return group;
    }
}


DotCollider = function ()
{
    this.list = [];

    this.add = function (point, radius)
    {
        this.list.push({ point: new Point(point), radius: radius });
    }

    this.hitTest = function (point, radius)
    {
        for (var i = 0; i < this.list.length; i++) {
            var dot = this.list[i];
            var distSquared = point.getDistance(dot.point, true);
            var r = dot.radius + radius;
            if (distSquared < r*r) {
                return true;
            }
        }
        return false;
    }
}


Panel = function ( growth, scale, panelId )
{
    this.growth = growth;
    this.scale = scale;
    this.panelId = panelId;
    this.json = growth.json.panels[panelId];

    this.drawOutline = function ()
    {
        var path = new Path(this.json.outline);
        path.closePath(true);
        return path;
    }

    this.strokeOutline = function (radius)
    {
        var outline = this.drawOutline();
        var result = strokePath(outline, radius);
        outline.remove();
        return result;
    }

    this.outlineSupports = function ()
    {
        // Support pieces for the panel's outline

        var outline = this.drawOutline();
        var result = this.strokeOutline( this.scale.supportWidth ).intersect(outline);
        outline.remove();
        return result;
    }

    this.nudgeLargeDot = function (json)
    {
        // The simulation may give us dots that need to move slightly in order to
        // have enough clearance for support pieces. Do that in the JSON model before
        // we use it for anything else.

        // TODO: Assumes panels are rectangular and axis-aligned

        var clearance = 0.001 + json.radius
            + this.scale.supportWidth
            + this.scale.ledSpreadDistance;

        json.center.x = Math.max(json.center.x, this.bounds.left + clearance);
        json.center.x = Math.min(json.center.x, this.bounds.right - clearance);

        json.center.y = Math.max(json.center.y, this.bounds.top + clearance);
        json.center.y = Math.min(json.center.y, this.bounds.bottom - clearance);
    }

    this.placeLargeDot = function (json)
    {
        this.frontHoles.push(new Path.Circle(json.center, json.radius));

        // Support for fully isolated LED strip around the dot, pointed inward
        var ledRadius = json.radius + this.scale.ledSpreadDistance;
        var outerRadius = ledRadius + this.scale.supportWidth;

        this.middleSupports.push(new Path.Circle(json.center, outerRadius));
        this.middleHoles.push(new Path.Circle(json.center, ledRadius));

        // Large keepout area
        this.collider.add(json.center, outerRadius);
    }

    this.canPlaceSmallDot = function (point)
    {
        if (!this.bounds.contains(point)) {
            // Not on this panel, early out.
            return false;
        }

        var testRadius = this.scale.smallDotRadius + this.scale.smallDotGap;
        return !this.collider.hitTest(point, testRadius) &&
               !this.keepOut.contains(point);
    }

    this.placeSmallDot = function (point)
    {
        this.collider.add(point, this.scale.smallDotRadius);
        this.frontHoles.push(new Path.Circle(point, this.scale.smallDotRadius));
    } 

    this.placeStrand = function (json)
    {   
        var path = new Path(json.points);
        if (path.bounds.intersects(this.bounds)) {

            var offset = 0;
            var length = path.length;
            var dotsToPlace = []

            while (offset < length) {
                var point = path.getPointAt(offset);
                var tangent = path.getTangentAt(offset);

                if (this.canPlaceSmallDot(point)) {
                    // Place the dots later so we don't collide-test on the same strand
                    dotsToPlace.push(point);
                }

                offset += this.scale.smallDotRadius * 2 + this.scale.smallDotGap;
            }

            for (var i = 0; i < dotsToPlace.length; i++) {
                this.placeSmallDot(dotsToPlace[i]);
            }
        }
        path.remove();
    }

    this.bounds = this.drawOutline().bounds;
    this.collider = new DotCollider();
    this.keepOut = this.strokeOutline(this.scale.smallDotGap + this.scale.supportWidth);

    this.frontHoles = [];
    this.middleSupports = [];
    this.middleHoles = [];

    for (var i = 0; i < this.growth.json.dots.length; i++) {
        var dot = this.growth.json.dots[i];
        if (this.bounds.contains(dot.center)) {
            this.nudgeLargeDot(dot);
            this.placeLargeDot(dot);
        }
    }

    for (var i = 0; i < this.growth.json.strands.length; i++) {
        this.placeStrand(this.growth.json.strands[i]);
    }

    this.frontLayer = this.drawOutline().subtract(new CompoundPath(this.frontHoles));
    this.middleLayer = new CompoundPath(this.middleSupports)
        .subtract(new CompoundPath(this.middleHoles))
        .unite(this.outlineSupports());
    this.backLayer = this.drawOutline();

    this.draw = function () {
        this.backLayer.fillColor   = '#21abff';                     // Bright rear layer
        this.middleLayer.fillColor = new Color(0, 0.6, 0, 0.8);     // Green support layer
        this.frontLayer.fillColor  = new Color(0, 0.7);             // Dark front layer

        var group = new Group();
        group.addChild(this.backLayer);
        group.addChild(this.middleLayer);
        group.addChild(this.frontLayer);
        return group;
    }
}
